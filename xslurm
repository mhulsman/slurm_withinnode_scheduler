#!/usr/bin/env python
import curses, curses.textpad, curses.ascii
import os
import subprocess, sys, getopt, time,shlex
from subprocess import Popen
import thread
import threading
from collections import defaultdict, OrderedDict

from SimpleXMLRPCServer import SimpleXMLRPCServer
import random
import psutil
import shutil
import numpy
import getpass

import xslurm_shared


WHITE=0
RED=1
GREEN=2
YELLOW=3
MAGENTA=4
BLUE=5
CYAN=6

TIMEOUT = 1500

#current screen info
class gb:
    scr = None
    lock = None

    wlog = None
    wlog_currow = 0
    wlog_size = (0,0)

    wcom = None
    wcom_status = None
    
    wstatus = None
    wstatus_progress = None

class status:
    lock = None
    
    local_engine = None

    cluster_engines = []
    cluster_stats = (0,0,0)
    cluster_node_info = {}

    
    stop_status_display = False


#create a bordered window
def border_win(parent,height,width,x,y,**kwargs):
    if(not 'notop' in kwargs):
        parent.hline(x,y,'.',width)
        height -= 1
        x += 1
    if(not 'nobottom' in kwargs):
        parent.hline(x+height-1,y,'.',width)
        height -= 1
    if(not 'noleft' in kwargs):
        parent.vline(x,y,'.',height)
        width -= 1
        y += 1
    if(not 'noright' in kwargs):
        parent.vline(x,y+width-1,'.',height)
        width -= 1
    w = parent.subwin(height, width,x,y)
    w.noutrefresh()
    parent.refresh()
    return w


#threaded output of a file to the log window
def thread_log_output(file, gb, color, filter):
    while 1 :
        line = file.readline()
        if (not line):
            break
         
        if (filter and len([f for f in filter if f in line]) > 0) :
            pass
        else:    
            add_log_line(gb,line,color)

def log_output(file, gb, color = 0, filter = []):
    t = thread.start_new_thread(thread_log_output, (file, gb, color, filter))
    return t

def get_slurm_stats(status):
    cmd = "squeue -h --user " + getpass.getuser() + " --name xslurm -o '%A|%L|%t'" 

    args = shlex.split(cmd)
    p = Popen(args,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
    output = p.communicate()[0]

    output = [e.split('|')  for e in output.split("\t") if e]
    
    z = defaultdict(int)

    last_state = {}
    for row in output:
        z[row[2]] += 1
        last_state[row[0]] = (row[2], row[1])

    res = (len(status.cluster_engines),z['PD'],z['R'])
    return (res, last_state)


def get_job_stats(Commands):
    njobs = len(Commands.jobs_by_id)
    nrunning = 0
    for job in Commands.jobs_by_id.values():
        if job.state == 'R':
            nrunning += 1
    return (njobs, nrunning)


def get_stat_str(stats):
    cpu,memp,mempmax,mem,memmax = stats
    if(cpu < 0.50 or mempmax > 0.90):
        color = RED
    elif(cpu < 0.80 or mempmax > 0.70):
        color = YELLOW
    else:
        color = GREEN

    descr = "(" +  '{:.2%}'.format(cpu) + " CPU, " + \
            '{:.2%}'.format(memp) + "/" + '{:.2%}'.format(mempmax)  + "/" + \
            '{}'.format(int(mem)) + "MB MEM)"
    return descr,color

def get_local_engine_stats(status):
    status.lock.acquire()
    if not status.local_engine is None:
        if status.local_engine.poll() != None:
            status.local_engine = None

    status.lock.release()
    return status.local_engine != None

#thread display status
def thread_display_status(gb,status):
    while not status.stop_status_display:
        stats, node_job_info = get_slurm_stats(status)
        njobs, nrunning = get_job_stats(Commands)
        local_running = get_local_engine_stats(status)
        
        status.lock.acquire()
        status.cluster_stats = stats
        status.cluster_node_info = node_job_info

        gb.lock.acquire()
        try:
            if(gb.wcom_status and gb.wcom_status.getmaxyx()[1] > 50):
                sizey = gb.wcom_status.getmaxyx()[1]
                gb.wcom_status.erase()
                gb.wcom_status.addstr(1,1,"Jobs: ")
                gb.wcom_status.addstr(1,18,"%d/%d" % (nrunning, njobs),curses.color_pair(GREEN))
                
                
                gb.wcom_status.addstr(3,1,"Local engine: ")
                if not local_running:
                   gb.wcom_status.addstr(3,18,"NOT RUNNING",curses.color_pair(YELLOW))
                else:
                   gb.wcom_status.addstr(3,18,"RUNNING",curses.color_pair(GREEN))

                gb.wcom_status.addstr(5,1,"SLURM engines: ")
                nnodes, nqueue, nrunning = stats

                
                if nqueue == 0:
                    color = GREEN
                else:
                    color = YELLOW
                gb.wcom_status.addstr(5,18,"%d/%d" % (nrunning,nnodes),curses.color_pair(color))

                
                gb.wcom_status.refresh()
        except Exception,e:
            add_log_line(gb,"Exception in display thread: " + str(e), RED)
        finally:
            gb.lock.release()
            status.lock.release()
        time.sleep(1)

def start_status_display(gb,status):
    status.stop_status_display = False
    t = threading.Thread(target=thread_display_status,args=(gb,status))
    t.daemon=True
    t.start()
    return t

def stop_status_display(status,t):
    set_status_message(gb, "Waiting for status thread to terminate..", YELLOW)
    status.stop_status_display = True
    t.join()

#initialize windows/lock, etc.
def build_windows(gb):
    if(not gb.lock): 
        gb.lock = threading.RLock()
    gb.lock.acquire()
    try:
        
        #clear screen in curses does not work somehow. 
        print "\033[2J"

        gb.scr.erase()
        gb.scr.refresh()
        curses.start_color()
        # Invisibility mode of the cursor may not be supported by the terminal
        try :
            curses.curs_set(0)
        except :
            pass
        
        #curses getmaxyx does not work for resize screens to smaller sizes. Use stty instead. 
        rows, columns = os.popen('stty size', 'r').read().split()       
        size = (int(rows), int(columns))

        com_win_rows = max(0,min(20,size[0]-2))
        status_win_rows = max(0,min(2,size[0] - com_win_rows))
        log_win_rows = max(0,size[0] - com_win_rows - status_win_rows)


        #init colors
        curses.init_pair(RED,curses.COLOR_RED,curses.COLOR_BLACK)
        curses.init_pair(GREEN,curses.COLOR_GREEN,curses.COLOR_BLACK)
        curses.init_pair(YELLOW,curses.COLOR_YELLOW,curses.COLOR_BLACK)
        curses.init_pair(MAGENTA,curses.COLOR_MAGENTA,curses.COLOR_BLACK)
        curses.init_pair(BLUE,curses.COLOR_BLUE,curses.COLOR_BLACK)
        curses.init_pair(CYAN,curses.COLOR_CYAN,curses.COLOR_BLACK)
        
        #log window
        if(log_win_rows > 2):
            gb.wlog = border_win(gb.scr,log_win_rows,size[1],0,0)
            gb.wlog_size = gb.wlog.getmaxyx()
            gb.wlog_currow = 0
            gb.wlog.setscrreg(0,gb.wlog_size[0]-1)
            gb.wlog.idlok(True)
            gb.wlog.scrollok(True)
            gb.wlog.refresh()
        else:
            gb.wlog = None

        #com window
        if(com_win_rows > 10):
            com_win_cols = size[1] / 2
            if(com_win_cols > 55):
                comlog_win_cols = size[1] - 55
                com_win_cols = 55
                gb.wcom_status = border_win(gb.scr,com_win_rows,comlog_win_cols,log_win_rows,com_win_cols,notop=True,noleft=True)
                gb.wcom_status.refresh()
            else:
                com_win_cols = size[1]
                gb.wcom_status = None
        
            gb.wcom = border_win(gb.scr,com_win_rows,com_win_cols,log_win_rows,0,notop=True)
            gb.wcom.refresh()
        else:
            gb.wcom = None
            gb.wcom_status = None
        
        #status window
        if(status_win_rows == 2):
            gb.wstatus = gb.scr.subwin(status_win_rows,size[1],log_win_rows + com_win_rows,0)
            gb.wstatus.refresh()
        else:
            gb.wstatus = None

        init_commands(gb)
        gb.scr.refresh()
    except:
        pass
    finally:
        gb.lock.release()    

#add line to log windows
def add_log_line(gb,line,color=0):
    gb.lock.acquire()
    try:
        if(line and line[-1] == '\n'):
            gb.log_file.write(line)
        else:
            gb.log_file.write(line + '\n')
        if(gb.wlog):
            try:
                line = str(line.decode('ascii'))
            except UnicodeDecodeError:
                line = "Invalid line format (unicode) encountered"
                color = RED
            line = line[:(gb.wlog_size[1] - 2)]
            if(line and line[-1] == '\n'): line = line[:-1]
            if(gb.wlog_currow < gb.wlog_size[0]):
                gb.wlog.addstr(gb.wlog_currow,1,line,curses.color_pair(color))
                gb.wlog_currow += 1
            else:
                gb.wlog.scroll()
                gb.wlog.addstr(gb.wlog_size[0] - 1,1,line,curses.color_pair(color))
            gb.wlog.refresh()
    except Exception, e:
        print e
    finally:
        gb.lock.release()

#set status message iin status window
def set_status_message(gb, line, color = 0):
    gb.lock.acquire()
    try:
        if (gb.wstatus) :
            gb.wstatus.addstr(0,0,line,curses.color_pair(color))
            gb.wstatus.clrtoeol()
            gb.wstatus.refresh()
    except Exception, e:
        pass
    finally:
        gb.lock.release()

def set_progress_bar(gb,s):
    gb.lock.acquire()
    try:
        if(gb.wstatus):
            if(s < 0.0 or s > 1.0):
                add_log_line(gb, "Progress bar value out of range: " + str(s),RED)
            else:
                size = gb.wstatus.getmaxyx()
                total_i = size[1] - 3
                full_i = int(s * total_i)
                rem_i = total_i - full_i
                line = "[" + ('#' * full_i) + (' ' * rem_i) + "]"
                gb.wstatus.addstr(1,0,line,curses.color_pair(MAGENTA))
                gb.wstatus.clrtoeol()
                gb.wstatus.refresh()
    except Exception,e:
        add_log_line(gb,"Exception in set_progress_bar: " + str(e),RED)
    finally:
        gb.lock.release()

def stop_progress_bar(gb):
    gb.lock.acquire()
    try:
        if(gb.wstatus):
            gb.wstatus.addstr(1,0,"")
            gb.wstatus.clrtoeol()
            gb.wstatus.refresh()
    except Exception, e:
        pass
    finally:
        gb.lock.release()

#print commands in command windows
def init_commands(gb):
    gb.lock.acquire()
    try:
        if not gb.wcom is None:
            gb.wcom.addstr(1,1,"Start/stop local engine: s/x")
            gb.wcom.addstr(2,1,"Start/stop SLURM engines: d/c [n]")
            #gb.wcom.addstr(5,1,"Autogrow SLURM engines: g")
            #gb.wcom.addstr(6,1,"Autocancel SLURM engines: h")
            gb.wcom.addstr(9,1,"Shutdown: q")
            gb.wcom.refresh()
    except Exception, e:
        pass
    finally:
        gb.lock.release()

#enter command in command window
def enter_command(gb,argument="Command: "):
    if gb.wcom is None:
        return
    gb.lock.acquire()
    try:
        command = ""
        size = gb.wcom.getmaxyx()
        x = size[0] - 1
        gb.wcom.addstr(x,1,argument)
        gb.wcom.clrtoeol()
        gb.wcom.refresh()
        while 1:
            gb.lock.release()
            c = gb.scr.getch()
            gb.lock.acquire()
            if c == curses.ascii.LF:
                break
            elif c == curses.ascii.DEL:
                command = command[:-1]
            else:
                if(c > 256):
                    set_status_message(gb,"Keycode not supported: " + str(c))
                else:
                    command += chr(c)
            gb.wcom.addstr(x,1,argument + command[:(size[1] - len(argument) - 2)])
            gb.wcom.clrtoeol()
            gb.wcom.refresh()

        gb.wcom.addstr(x,1,"")
        gb.wcom.clrtoeol()
        gb.wcom.refresh()
    finally:
        gb.lock.release()
    return command

def get_number(gb,argument,default=0):
    cmd = enter_command(gb,argument)
    if(not cmd):
        n = default
    else:
        try:
            n = int(cmd)
        except ValueError:
            set_status_message(gb,"Number of engines should be a number",YELLOW)
            n = None
    return n

def start_local(gb,status, ncpu, mem):
    status.lock.acquire()
    try:
        if(ncpu <= 0 or mem <= 0):
            set_status_message(gb,"Invalid cpu (%d) or mem (%.2g gb) constraint. " % (ncpu, mem / 1024.0), YELLOW)
        else: 
            set_status_message(gb,"Starting local engines", YELLOW)
            chief_path = os.path.dirname(os.path.realpath(__file__)) + "/xslurm_chief"
            cmd = chief_path + " -a " + str(status.address) + " -p " + str(status.port) + " -c %d" % ncpu + " -m %d" % int(mem)
            add_log_line(gb,"Starting local engine using: " + cmd, GREEN)
            args = shlex.split(cmd)
        
            e = Popen(args,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
            log_output(e.stderr,gb,RED)
            status.local_engine = e

            set_status_message(gb,"Local engine started", GREEN)
            add_log_line(gb,"Local engine started", MAGENTA)
    finally:
        status.lock.release()

def stop_local(gb,status):
    status.lock.acquire()
    try:
        if(status.local_engine is None):
            set_status_message(gb,"No local engine running",YELLOW)
        else:
            set_status_message(gb,"Stopping local engine",YELLOW)
            stop_engine = status.local_engine
            status.local_engine = None
            if stop_engine.poll() is None:
                stop_engine.terminate()

            set_status_message(gb,"Local engines stopped",GREEN)
            add_log_line(gb,"Local engine stopped",MAGENTA)
    finally: 
        status.lock.release()

#FIXME
def start_slurm(gb,status,n):
    status.lock.acquire()
    try:
        if(not controller_online(status)):
            set_status_message(gb,"Controller is not online",YELLOW)
        elif(n < 0):
            set_status_message(gb,"Invalid number of engines to be started: " + str(n),YELLOW)
        else: 
            set_status_message(gb,"Starting PBS engines",YELLOW)
            engine_path = os.path.dirname(os.path.realpath(__file__))
            cmd = "qsub -N ipython_engine -k n -V -v EPATH=" + engine_path + ",ADDRESS=" + status.address + ",PORT=" + status.port + " " + engine_path + "/ipython_engine"
            add_log_line(gb,"Starting engines using: " + cmd,GREEN)
            args = shlex.split(cmd)
        
            for i in range(n):
                eid = Popen(args,stdout=subprocess.PIPE,stderr=subprocess.PIPE).communicate()[0]
                status.pbs_engines.append(eid)
            time.sleep(2)
            set_status_message(gb,"PBS engines queued",GREEN)
            add_log_line(gb,str(n) + " PBS engines queued",MAGENTA)
    finally:
        status.lock.release()

#FIXME
def stop_slurm(gb,status,n):
    status.lock.acquire()
    try:
        if(not status.pbs_engines and n != 0):
            set_status_message(gb,"No PBS engines running",YELLOW)
        elif(n < 0 or n > len(status.pbs_engines)):
            set_status_message(gb,"Invalid number of engines to be stopped: " + str(n),YELLOW)
        else:
            set_status_message(gb,"Stopping PBS engines",YELLOW)
            stop_engines = status.pbs_engines[-n:]
            status.pbs_engines = status.pbs_engines[:-n]
            set_progress_bar(gb,0.0)
            for i,eid in enumerate(stop_engines):
                cmd = "qdel " + eid
                args = shlex.split(cmd)
                p = Popen(args,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
                log_output(p.stdout,gb,WHITE)
                log_output(p.stderr,gb,RED)
                p.wait()
                set_progress_bar(gb,float(i+1)/float(n))
            
            time.sleep(2)
            stop_progress_bar(gb)
            set_status_message(gb,"PBS engines stopped",GREEN)
            add_log_line(gb,str(n) + " PBS engines stopped",MAGENTA)
    finally: 
        status.lock.release()


def init_status(status,address,port):
    status.lock = threading.RLock()
    status.address = address
    status.port = port

#COMMANDS
NOOP=0
STOP=1
DIE=2
CANCEL=3
REREGISTER=4

#MODES
RUNNING = 1
STOPPING= 2

class Commands:
    lock = None
    manager_server = None
    job_server = None

    active_engines = dict()
    engine_info = dict()
    engine_stats = dict()
    pending_commands = {}

    usage_stats = (0.0, 0.0)
    
    
    jobid_counter = numpy.random.randint(0, 1000000)
    jobs_by_id = OrderedDict()


def register(myip,cores,totmem):
    Commands.lock.acquire()
    try:
        myid = myip
        if myip in Commands.active_engines:
            myid = 'DENIED'
            add_log_line(gb,"Secondary engine on " + myip + ' was denied',RED)
        else:
            Commands.engine_info[myid] = (cores,totmem)
            Commands.active_engines[myid] = time.time()
            Commands.engine_stats[myid] = (0.0,0.0)
            Commands.pending_commands[myid] = []
        
            totalgb = totmem / 1024.0
            average_use = totalgb / float(cores)
        
            add_log_line(gb,"Engine (" + str(cores) + "C:" + "{:1.1f}".format(average_use) + " GB) on " + myip + ' is now online',CYAN)
    
    except Exception, e:            
        add_log_line(gb,"Exception in register: " + str(e),RED)
    finally:
        Commands.lock.release()
    return myid

def poll(myid, cpu_usage, mem_usage, mode):
    
    Commands.lock.acquire()
    try:
        commands = Commands.pending_commands[myid]
        Commands.active_engines[myid] = time.time()
        Commands.engine_stats[myid] = (cpu_usage,mem_usage)
        Commands.pending_commands[myid] = []
    except KeyError:
        if mode == STOPPING:
            add_log_line(gb,"Poll for unknown engine id: " + myid + ". Engine is stopping.",RED)
            commands.append((STOP,None))
        else:
            add_log_line(gb,"Poll for unknown engine id: " + myid + ". Taking ownership.",RED)
            commands.append((REREGISER,None))

    finally:
        Commands.lock.release()
    return commands
        

def unregister(myid) :
    _unregister(myid)
    add_log_line(gb,"Engine with id " + myid + " unregistered",CYAN)
    return True

def _unregister(myid):
    Commands.lock.acquire()
    try:
        del Commands.active_engines[myid]
        cmd = Commands.pending_commands.pop(myid)
        del Commands.engine_info[myid]
        del Commands.engine_stats[myid]
    except KeyError:
        add_log_line(gb,"Unregister request for unknown engine id: " + myid,RED)
    finally:
        Commands.lock.release()



def request_job(myid,current_cpu, current_mem, current_time):
    res =  (None, None, None, None, None, None)
    
    add_log_line(gb,"Node %s requests for job with %d cpus and %d mb mem within %s time" % (myid, current_cpu, current_mem, current_time), BLUE)

    Commands.lock.acquire()
    for job in Commands.jobs_by_id.values():
        #FIXME; assume 5 days of time
        if job.state == 'PD' and job.ncpu <= current_cpu and job.mem <= current_mem and job.reqtime <= (5 * 24 * 60.0) - current_time:
            add_log_line(gb,"Job (id: %s) started on node %s" % (job.jobid, myid), BLUE)
            job.state = 'R'
            job.node_id = myid
            add_log_line(gb, str(job.env), CYAN)
            res =  (job.jobid, job.command, job.cwd, job.env, job.ncpu, job.mem)
        
    Commands.lock.release()
    return res



def job_finished(myid, jobid, return_code):
    #FIXME: add in requeue stuff
    Commands.lock.acquire()
    del Commands.job_by_id[jobid]
    Commands.lock.release()
    
    
    if return_code == 0:
        add_log_line(gb,"Job (id: %s) completed." % jobid,GREEN)
    else:
        add_log_line(gb,"Job (id: %s, node: %s) completed." % (jobid, myid),YELLOW)




def thread_start_manager_server(port):
    Commands.lock = threading.RLock()
    server = SimpleXMLRPCServer(("", int(port)), logRequests = False, allow_none=True)
    server.register_function(register)
    server.register_function(unregister)
    server.register_function(poll)
    server.register_function(request_job)
    server.register_function(job_finished)
    Commands.manager_server = server
    server.serve_forever()



class Job(object):
    def __init__(self, job_name, jobid, command, cwd, env, ncpu, mem, reqtime, requeue, dependency):
        self.job_name = job_name
        self.jobid = jobid
        self.command = command
        self.cwd = cwd
        self.env =env
        self.ncpu = ncpu
        self.mem = mem
        self.reqtime = reqtime
        self.requeue = requeue
        self.dependency = dependency

        self.state= 'PD'
        self.node_id = None
        self.starttime = None


def submit_job(job_name, cmd, cwd, env, ncpu, mem, reqtime, requeue, dependency):
    Commands.lock.acquire()
    jobid = str(Commands.jobid_counter)
    Commands.jobid_counter += 1
   

    #weird xml-rpc problem?
    if len(env) == 1 and 'data' in env:
        env = env['data']

    add_log_line(gb, str(env), CYAN)
    job = Job(job_name, jobid, cmd, cwd, env, ncpu, mem, reqtime, requeue, dependency)
    Commands.jobs_by_id[jobid] = job

    Commands.lock.release()
    add_log_line(gb,"Job (id: %s, ncore: %d, mem: %d mb) submitted." % (jobid, ncpu, mem),GREEN)
    return jobid

def cancel_job(jobid):
    Commands.lock.acquire()
    job = None
    if jobid in Commands.jobs_by_id:
        job = Commands.jobs_by_id[jobid]
        if job.state == 'R':
            node_id = job.node_id
            Commands.pending_commands[nodeid].append(('CANCEL',jobid))
        del Commands.jobs_by_id[jobid]
    Commands.lock.release()
    if job is None:
        add_log_line(gb,"Attempt to cancel unknown job (id: %s)." % jobid,YELLOW)
    elif job.state == 'R':
        add_log_line(gb,"Job (id: %s, running on %s) cancelled." % (job.jobid, job.node_id),YELLOW)
    else:
        add_log_line(gb,"Job (id: %s) cancelled." % job.jobid,YELLOW)

def list_jobs():
    jobs = []
    for job in Commands.jobs_by_id.values():
        if not job.starttime is None:
            runtime = time.time() - job.starttime
        else:
            runtime = 0.0

        if job.node_id is None:
            node_id = '(Resources)'
        else:
            node_id = job.node_id

        jobs.append([job.jobid, job.job_name, job.state, runtime, job.ncpu, node_id])

    return jobs        


def thread_start_job_server(port):
    Commands.lock = threading.RLock()
    server = SimpleXMLRPCServer(("", int(port)), logRequests = False, allow_none=True)
    server.register_function(submit_job)
    server.register_function(cancel_job)
    server.register_function(list_jobs)
    Commands.job_server = server
    server.serve_forever()


def thread_check_commands():
    while 1:
        Commands.lock.acquire()
        try:
            active_engines = Commands.active_engines.copy()
            engine_stats = Commands.engine_stats.copy()
            engine_info = Commands.engine_info.copy()
        finally:
            Commands.lock.release()
        now = time.time()
        for eid,last_seen_time in active_engines.iteritems():
            if now - last_seen_time > TIMEOUT :
                _unregister(eid)
                add_log_line(gb,"Engine with id " + eid + " timed out",RED)
        
        et_stats = defaultdict(list)
        
        used_cpus = 0
        used_mem = 0
        total_cpus = 0
        total_mem = 0
        max_mem_usage = 0.0
        max_cpu_usage = 0.0
        for eid in engine_stats.keys():
            cpus,mem = engine_info[eid]
            cpu_usage,mem_usage = engine_stats[eid]

            total_cpus += cpus
            total_mem += mem / (1024.0)

            used_cpus = cpus * (cpu_usage/100.0)
            used_mem = (mem / 1024.0) * (mem_usage/100.0)

            max_mem_usage = max(max_mem_usage, mem_usage/100.0)
            max_cpu_usage = max(max_cpu_usage, cpu_usage/100.0)

        usage_stats = (used_cpus, total_cpus, max_cpu_usage, used_mem, total_mem, max_mem_usage)

    	status.lock.acquire()
    	try:
             status.engine_stats = engine_stats
        finally:
             status.lock.release()

        time.sleep(5)


def start_server(port):
    t = threading.Thread(target=thread_start_manager_server,args=(port,))
    t.daemon=True
    t.start()
    
    t = threading.Thread(target=thread_start_job_server,args=(port+1,))
    t.daemon=True
    t.start()

    t = threading.Thread(target=thread_check_commands)
    t.daemon=True
    t.start()


def main(scr, *args, **kwds):
    address = xslurm_shared.get_hostname()
    port = xslurm_shared.port

    init_status(status,address,port)
    
    gb.scr = scr
    gb.log_file = open('cluster.log','w')

    build_windows(gb)
    t = start_status_display(gb,status)
    start_server(port)
   

    #workaround for bug in curses: no resize messages
    os.environ['LINES']="blah"
    del os.environ['LINES']
    os.environ['COLUMNS']="blah"
    del os.environ['COLUMNS']

    try:
        while 1:
            c = gb.scr.getch()
            if c == curses.KEY_RESIZE:
                build_windows(gb)
            elif c == ord('q'):  #QUIT
                ans = enter_command(gb, "Are you sure? (yes/no): ")
                if ans == 'yes':
                    stop_status_display(status,t)
                    gb.scr.refresh()
                    break
            elif c == ord('s'):  #START local engine
                cpus = get_number(gb, "Number of cpus (def=23): ", 23)
                mem = get_number(gb, "Maximal memory in GB (def=62): ", 62)
                if(not cpus is None and not mem is None):
                    start_local(gb,status,cpus,mem * 1024.0)

            elif c == ord('x'):  #STOP local engines
                stop_local(gb,status)

            elif c == ord('d'):  #START SLURM engines
                cmd = get_number(gb, "Number of engines (def=4): ",4)
                if(not cmd is None):
                    start_slurm(gb,status,cmd)

            elif c == ord('c'):  #STOP PBS engines
                cmd = get_number(gb, "Number of engines (def=all): ",len(status.cluster_engines))
                if(not cmd is None):
                    stop_slurm(gb,status,cmd)

    	    elif c == ord('u') :  # Update ncurses screen
                gb.scr.refresh()
    except Exception:
        add_log_line(gb,"EXCEPTION!!! EMERGENCY SHUTDOWN IN PROGRESS!",RED)
        try:
            stop_status_display(status,t)
        except Exception:
            pass
        raise
        
    time.sleep(2) #wait for all paint ops to finish
curses.wrapper(main)
